extends ./base.pugtemplate
block body-outer
    #canvas
block postbody
    style.
        * { transition: 0s !important; }
        header, footer { display: none !important; }
        body, .main { overflow: hidden; }
        #canvas { image-rendering: crisp-edges; }
        .picture-wrapper { 
            position: absolute; 
            width: 0; height: 0;
        }
        .picture { position: absolute; }
        .shadow { mix-blend-mode: multiply; }
        .invert { filter: invert(); }
    script.
        let WS_DIR = "", BASE_DIR = "";
        let P = {};
        let animator = [];
        class Picture {
            async init(id, x, y, parent = null, px = null, py = null, override = null) {
                this.id = id; this.var = {};
                this.x = x; this.y = y; this.z = 0;
                this.parent = P[parent]; this.px = px; this.py = py;
                this.scalex = 1; this.scaley = 1;
                this.wrapper = insertElement("div", this.parent?.wrapper ?? "canvas", "picture-wrapper").with("id", this.id);
                if (override === null || typeof override === "string") {
                    let src = (override ?? this.id).startsWith("//") ? (override ?? this.id) : "//prod.kr/images/" + BASE_DIR + "/" + (override ?? this.id) + ".png";
                    this.image = insertElement("img", this.wrapper, "picture").with("id", this.id + "-img").with("src", src);
                    await new Promise(resolve => { this.image.onload = resolve; this.image.onerror = () => { this.image.src = ""; resolve(); } });
                }
                else {
                    this.image = override;
                    this.wrapper.appendChild(this.image);
                }
                this.animation = {}; this.animationFrame = 0;
                this.w = this.image.width ?? 0; this.h = this.image.height ?? 0; this.a = 0; this.alpha = 1;
                if (nullish(this.px) !== null) { this.px -= this.w / 2; this.x += this.px / 2; } else this.px = 0;
                if (nullish(this.py) !== null) { this.py -= this.h / 2; this.y += this.py / 2; } else this.py = 0;
                let par = this.parent;
                while (par) { this.x -= par.x; this.y -= par.y; par = par.parent; }
                this.applyMovement();
                P[this.id] = this;
                return this;
            }
            getPos() { 
                let x = 0; let y = 0; let a = 0; 
                let el = this; while (el) {
                    if (el.a !== 0) {
                        let r = Math.hypot(x, y); let theta = Math.atan2(y, x);
                        x = r * Math.cos(theta + (el.a / 180 * Math.PI));
                        y = r * Math.sin(theta + (el.a / 180 * Math.PI));
                    }
                    x += el.x; y += el.y; a += el.a;
                    el = el.parent; 
                }
                return {x: x, y: y, a: a}; 
            }
            setPos(x, y) { if (nullish(x) !== null) this.x = x; if (nullish(y) !== null) this.y = y; this.applyMovement(); return this; }
            setScale(x, y) { if (nullish(x) !== null) { this.scalex = x; this.scaley = nullish(y) !== null ? y : x; } this.applyMovement(); return this; }
            move(x, y) { if (nullish(x) !== null) this.x += x; if (nullish(y) !== null) this.y += y; this.applyMovement(); return this; }
            setDepth(z) { this.z = z; this.wrapper.style.zIndex = this.z; this.image.style.zIndex = this.z; return this; }
            rotate(a, absolute=false) { this.a = absolute ? a : this.a + a; this.applyMovement(); return this; }
            applyMovement() { 
                this.wrapper.style.transform = `translate(${this.x}px, ${this.y}px) rotate(${this.a}deg)`; 
                this.image.style.transform = `translate(${-(this.px + (this.w / 2))}px, ${-(this.py + (this.h / 2))}px) scale(${this.scalex}, ${this.scaley})`; 
                return this;
            }
            setAlpha(a) { this.alpha = a; this.wrapper.style.opacity = this.alpha; return this; }
            setSprite(_src) {
                let src = _src.startsWith("//") ? _src : "//prod.kr/images/" + BASE_DIR + "/" + _src + ".png";
                if (this.image.src === src) return this;
                this.image.with("src", src);
                this.image.onload = () => {
                    this.w = this.image.width; this.h = this.image.height;
                    this.applyMovement();
                };
                return this;
            }
            setAnimation(anim) {
                if (animator.includes(this)) return this; animator.push(this);
                this.animation = anim; this.animationFrame = 0;
                return this;
            }
            addClass(cl) { this.image.classList.toggle(cl); return this; }
            destroy() { removeElement(this.wrapper); delete P[this.id]; for (let z of Object.keys(P).filter(x => P[x].parent === this)) P[z].destroy(); }
        }
        addEvent("onload", _init);
        async function _init() { 
            await init(); 
            // ws
            ws = new WebSocket("wss://prod.kr/" + WS_DIR);
            ws.addEventListener("open", () => {
                console.log("WebSocket opened");
            });
            ws.addEventListener("message", event => {
                const args = WASD.unpack(event.data);
                console.log("recieved message:", args);
                if (!COMMANDS[args[0]]) console.warn(args[0], "does not exist but recieved:", args);
                else COMMANDS[args[0]](...args.slice(1));
            });
            _update(); 
        }
        async function init() {}
        let targetFPS = 60; let tickSpeed = 1; let pause = false;
        let frameTime = time(); let frameCount = 0; let tick = 0;
        async function _update() {
            let deltaTime = Number(time() - frameTime) / 1000 * tickSpeed;
            frameTime = time(); frameCount++; tick += deltaTime;
            if (!pause) {
                update();
                // animation
                let toDeleteMeta = [];
                for (let el of animator) {
                    el.animationFrame += deltaTime;
                    const keys = Object.keys(el.animation).map(numberish);
                    const toDelete = keys.filter(x => x <= el.animationFrame);
                    if (toDelete.length === 0) continue;
                    const key = Math.max(...toDelete); 
                    if (el.animation[key] !== null) el.setSprite(el.animation[key]);
                    else toDeleteMeta.push(el);
                    for (const k of toDelete) delete el.animation[k];
                }
                animator = remove(animator, ...toDeleteMeta);
            }
            setTimeout(_update, 1000 / targetFPS);
        }
        function update() {}
        let ws;
        let ID = 0, waitList = {};
        function send(...msg) {
            if (ws?.readyState !== 1) return new Promise(resolve => { resolve(undefined); }); ID++;
            ws.send(WASD.pack(ID, ...msg));
            return new Promise(resolve => waitList[ID] = resolve);
        }
        let COMMANDS = {
            error: o => console.error(o),
            info: o => console.log(o),
            respond: (id, o) => { if (waitList[id]) { waitList[id](o); delete waitList[id]; }},
            exec: eval
        }
        function startAnimation(el, animation) {
            if (typeof el === "string") el = document.getElementById(el);
            el.style.animation = 'none';
            el.offsetHeight; /* trigger reflow */
            el.style.animation = animation; 
        }
    block content