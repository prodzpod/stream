extends ../template/base.pugtemplate

block meta
    - v = true
    - title = 'the screen'
    - description = 'the gizmo interaction panel'
block body 
    h1 The Screen 
    .screen-wrapper
        .hlist 
            button(onclick='flip()') flip
            p#point
        div(style='margin: 16px;')
        .screen#screen-wrapper
            canvas#screen(onclick='screen(event)')
        .screen#twitch-embed(style='display: none;') 
        div(style='margin: 16px;')
        .hlist.center#buttons(style='display: none;')
            button(onclick='pointButton()') point 
            button(onclick='clickButton()') click
            button(onclick='flingButton()') fling
            button(onclick='spawnButton()') spawn window
        p#status
        p#cmd
        .vlist#window-setting(style='display: none;')
            .hlist
                input#window-title.spacer
                span title
            .hlist
                textarea#window-content.spacer
                span content

block postbody
    style.
        .screen, .screen iframe {
            width: calc(100vw - 128px);
            height: calc((100vw - 128px) * 0.5625);
        }
    script.
        let flipped = false;
        let socket;
        function flip() {
            flipped = !flipped;
            e('screen-wrapper').style.display = flipped ? 'none' : 'block';
            e('twitch-embed').style.display = flipped ? 'block' : 'none';
        }
        let iu = 0;
        let objects = {};
        const Images = {
            activatewindows: new Image(),
            bg: new Image(),
            prod: new Image(),
            cursor_click: new Image(),
            cursor_point: new Image(),
        }
        addEvent('onload', async () => {
            let proms = [];
            for (k in Images) {
                Images[k].src = 'https://prod.kr/images/screen/' + k + '.png';
                proms.push(new Promise(resolve => Images[k].addEventListener("load", resolve)));
            }
            await Promise.all(proms);
            socket = new WebSocket("wss://prod.kr/screen");
            socket.addEventListener("open", (event) => { 
                console.log("Websocket Opened");
                setInterval(() => socket?.send('sync'), 60000);
            });
            socket.addEventListener("message", (event) => {
                let args = WASD.unpack(event.data);
                // console.log("Message recieved", args);
                switch (args[0]) {
                    case "auth":
                        e('point').innerHTML = `type <em>!login ${args[1]}</em> to log in`;
                        objects = JSON.parse(args[2]);
                        rebuild();
                        break;
                    case "points":
                        e('buttons').style.display = 'flex';
                        iu = Math.prec(Number(args[1]));
                        e('point').innerHTML = `<em>${iu}</em>iu`;
                        break;
                    case "update":
                        let newObjects = JSON.parse(args[1]);
                        for (let k in newObjects) objects[k] = safeAssign(objects[k], newObjects[k]);
                        rebuild();
                        break;
                    case "respond":
                        e('status').innerText = args[1];
                        state = "idle";
                        break;
                    case "sync":
                        let names = JSON.parse(args[1]);
                        for (let k of Object.keys(objects)) if (!names.includes(k)) delete objects[k];
                        let list = names.filter(x => objects[x] == (args[2] == "true"));
                        if (list.length) socket?.send(WASD.pack('request', JSON.stringify(list)));
                        break;
                }
            });
        });

        function rebuild() {
            const ctx = e("screen").getContext("2d");
            ctx.canvas.width = e('screen-wrapper').clientWidth;
            ctx.canvas.height = e('screen-wrapper').clientHeight;
            ctx.setTransform(ctx.canvas.width / 1920, 0, 0, ctx.canvas.height / 1080, 0, 0);
            ctx.clearRect(0, 0, 1920, 1080);
            ctx.fillStyle = "#396ba5";
            ctx.fillRect(0, 0, 1920, 1080);
            draw(ctx, '_prod', (ctx, _, x, y) => ctx.drawImage(Images.prod, x, y));
            ctx.drawImage(Images.bg, 0, 0, 1920, 1080);
            for (let k of Object.keys(objects).filter(x => x.startsWith("chat_"))) draw(ctx, k, drawChat);
            for (let k of Object.keys(objects).filter(x => x.startsWith("window_"))) draw(ctx, k, drawWindow);
            for (let k of Object.keys(objects).filter(x => x.startsWith("pointer_"))) draw(ctx, k, drawPointer);
            ctx.drawImage(Images.activatewindows, 1599, 988, 236, 39)
        }

        function drawPointer(ctx, o, x, y) {
            o.w = Number(o.w);
            o.h = Number(o.h);
            ctx.drawImage(o.sprite?.endsWith("cursor_point") ? Images.cursor_point : Images.cursor_click, x, y, o.w, o.h);
            ctx.fillStyle = o.color;
            ctx.fillText(o.author, x + 48, y + 0);
        }

        function drawChat(ctx, o, x, y) {
            o.w = Number(o.w);
            o.h = Number(o.h);
            ctx.fillStyle = "#d7d0c8";
            ctx.fillRect(x, y, o.w, o.h);
            ctx.fillStyle = o.color;
            ctx.fillText(o.author, x + 8, y + 12);
            ctx.fillStyle = "#000000";
            ctx.fillText(o.message, x + 8, y + 24);
        }

        function drawWindow(ctx, o, x, y) {
            o.w = Number(o.w);
            o.h = Number(o.h);
            ctx.fillStyle = "#000080";
            ctx.fillRect(x, y, o.w, o.h);
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(x + 4, y + 24, o.w - 8, o.h - 28);
            ctx.fillRect(x + o.w - 24, y + 4, 20, 20);
            ctx.fillText(o.title, x + 8, y + 12);
            ctx.fillStyle = "#000000";
            ctx.fillText("X", x + o.w - 16, y + 16);
            ctx.fillText(o.content, x + 8, y + 36);
        }

        function draw(ctx, k, fn) {
            let {x, y, w, h, a} = objects[k];
            ctx.save();
            ctx.setTransform(ctx.canvas.width / 1920, 0, 0, ctx.canvas.height / 1080, x * ctx.canvas.width / 1920, y * ctx.canvas.height / 1080);
            ctx.rotate(a / 180 * Math.PI);
            fn(ctx, objects[k], -w / 2, -h / 2, k);
            ctx.restore();
        }

        let state = "idle";
        let temp = {};
        function screen(event) {
            let r = e('screen').getBoundingClientRect()
            let x = Math.clamp((event.clientX - r.x) * (1920 / r.width), 1, 1919);
            let y = Math.clamp((event.clientY - r.y) * (1080 / r.height), 1, 1079);
            switch (state) {
                case "point":
                case "click":
                    socket?.send(WASD.pack(state, x, y));
                    e('status').innerText = "";
                    e('cmd').innerText = `command form: !${state} ${Math.floor(x)} ${Math.floor(y)}`;
                    state = "waiting";
                    break;
                case "fling1":
                    e('status').innerText = "select a destination";
                    temp.x = x; temp.y = y;
                    state = "fling2";
                    break;
                case "fling2":
                    socket?.send(WASD.pack('fling', temp.x, temp.y, x, y));
                    e('cmd').innerText = `command form: !fling ${Math.floor(temp.x)} ${Math.floor(temp.y)} ${Math.floor(x)} ${Math.floor(y)}`;
                    e('status').innerText = "";
                    state = "waiting";
                    break;
                case "spawn":
                {
                    let title = e('window-title').value;
                    let content = e('window-content').value
                    if (isNullOrWhitespace(title) || isNullOrWhitespace(content)) e('status').innerText = "one of the thing is empty";
                    else {
                        socket?.send(WASD.pack('spawn', x, y, title, content));
                        e('window-setting').style.display = 'none';
                        e('status').innerText = "";
                        e('cmd').innerText = `command form: !spawn ${Math.floor(x)} ${Math.floor(y)} ${WASD.pack(title)} ${WASD.pack(content)}`;
                        state = "waiting";
                    }
                    break;
                }
            }
        }

        function pointButton() {
            if (state == "waiting") return;
            state = "point";
            e('window-setting').style.display = 'none';
            e('status').innerText = "select a position to point";
        }
        function clickButton() {
            if (state == "waiting") return;
            state = "click";
            e('window-setting').style.display = 'none';
            e('status').innerText = "select a position to click";
        }
        function flingButton() {
            if (state == "waiting") return;
            state = "fling1";
            e('window-setting').style.display = 'none';
            e('status').innerText = "select an object";
        }
        function spawnButton() {
            if (state == "waiting") return;
            state = "spawn";
            e('window-setting').style.display = 'flex';
            e('status').innerText = "put in fields and click on a screen (where to place it)";
        }
    script(src="https://player.twitch.tv/js/embed/v1.js")
    script(type="text/javascript").
        new Twitch.Player("twitch-embed", { channel: "prodzpod" });